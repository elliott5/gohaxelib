// Copyright 2013 The gohaxelib Authors listed in the AUTHORS file. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found in the LICENSE file.
  
import haxe.rtti.XmlParser;
import haxe.rtti.CType;
import sys.io.File;
import sys.io.FileOutput;
import sys.FileSystem;
import haxe.ds.StringMap;

typedef MethodOrField = { 
	var key:String;
	var super:String;
	var name:String;
	var body:String; 
}

class Haxelib2go {

	static var dotMap = new StringMap<MethodOrField>(); 
	
    static	var parser = new haxe.rtti.XmlParser(); // this variable is reinitialised for each file
	
    static function main() { // Main entry point
    	var out:String="";
    	var hdr:String="// Auto-generated by http://github.com/tardisgo/gohaxelib "+Date.now()+"\n";
		
		/* The standard library */
        out=xmlFile("api-xml/cross.xml","cross","X");
      	FileUtils.writeTextFileWithBOM(hdr+"package _cross\n"+
        	out,"_cross/defs.go");
        out=xmlFile("api-xml/cpp.xml","cpp","P");
      	FileUtils.writeTextFileWithBOM(hdr+"package _cpp\n"+
        	out,"_cpp/defs.go");
        out=xmlFile("api-xml/cs.xml","cs","R");
      	FileUtils.writeTextFileWithBOM(hdr+"package _cs\n"+
        	"type Rcs_internal____Function_VarArgsBase uintptr\n"+
        	out,"_cs/defs.go");
        out=xmlFile("api-xml/flash9.xml","flash","F");
      	FileUtils.writeTextFileWithBOM(hdr+"package _flash\n"+
        	out,"_flash/defs.go");
        out=xmlFile("api-xml/java.xml","java","J");
      	FileUtils.writeTextFileWithBOM(hdr+"package _java\n"+
        	"type Jjava_internal____Function_VarArgsBase uintptr\n"+
        	out,"_java/defs.go");
        out=xmlFile("api-xml/js.xml","js","S");
           	FileUtils.writeTextFileWithBOM(hdr+"package _js\n"+
        	out,"_js/defs.go");
        out=xmlFile("api-xml/neko.xml","neko","N");
      	FileUtils.writeTextFileWithBOM(hdr+"package _neko\n"+
        	out,"_neko/defs.go");
        out=xmlFile("api-xml/php.xml","php","H");
      	FileUtils.writeTextFileWithBOM(hdr+"package _php\n"+
        	out,"_php/defs.go");
        
		/* OpenFL */
		out=xmlFile("api-xml-openfl/Android.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_android\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/android.go");
		out=xmlFile("api-xml-openfl/BlackBerry.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_blackberry\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/blackberry.go");
		out=xmlFile("api-xml-openfl/Firefox.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_firefox\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/firefox.go");
		out=xmlFile("api-xml-openfl/Flash.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_flash\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/flash.go");
		out=xmlFile("api-xml-openfl/HTML5.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_html5\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/html5.go");
		out=xmlFile("api-xml-openfl/iOS.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_ios\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/ios.go");
		out=xmlFile("api-xml-openfl/Linux.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_linux\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/linux.go");
		out=xmlFile("api-xml-openfl/Mac.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_mac\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/mac.go");
		out=xmlFile("api-xml-openfl/Tizen.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_tizen\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/tizen.go");
		out=xmlFile("api-xml-openfl/Windows.xml","","X");
        FileUtils.writeTextFileWithBOM("// +build openfl_windows\n\n"+hdr+"package _openfl\n"+
        	out,"_openfl/windows.go");
    }
	
    static function xmlFile(f:String,t:String,h:String):String { // process a single file
        
    	trace("Creating Go shadow defintions for:",f,t,h);

		// standard code to load in the XML data and point at it's root node
		parser = new haxe.rtti.XmlParser();
		var data = sys.io.File.getContent(f);
        var doc = Xml.parse(data).firstElement();
        parser.process(doc,t);
        var tr = parser.root;
		
		// itterate through the TypeTree entries, appending to the output string as we go 
		dotMap = new StringMap<MethodOrField>(); //initialize the map
   		var out:String = "";
        for(t in tr)	
	       out += tt(t,h);

	    var superClasses = new StringMap<String>();
	    for(me in dotMap){
	    	//trace( me  );
	    	superClasses.set(me.key,me.super);
	    }
	    for(k in superClasses.keys()){
	    	//trace(k,superClasses.get(k),depth(superClasses,k));
	    	if(depth(superClasses,k)>0){
	    		var seenNames = new StringMap<Bool>();
	    		for(me in dotMap){
	    			if( me.key == k ){
		    			seenNames.set(me.name,true);
	    			}
	    		}
		    	//trace("PreMOT:",seenNames);
		    	out += superMOT(superClasses,k,superClasses.get(k),seenNames);
	    	}
	    }
	  
	    return out+"\n";    	
    }

    static function superMOT(m:StringMap<String>,base:String,cl:String,sn:StringMap<Bool>):String {
    	var ret:String="";
    	for(me in dotMap)
    		if(me.key == cl)
    			if(!sn.exists(me.name) ) {
    				ret += "\n// from superclass: " + me.key;
    				ret += "\nfunc (x "+base+") "+me.name+" "+me.body;
    				sn.set(me.name,true);
    			}
    	if(depth(m,cl)>0)
    		ret += superMOT(m,base,m.get(cl),sn);
    	return ret;
    }

    static function depth(m:StringMap<String>,i:String):Int {
    	if(!m.exists(i))
    		return 0;
    	if(m.get(i)=="uintptr")
    		return 0;
    	return 1+depth(m,m.get(i));
    }
	
    static function tt(t:haxe.rtti.TypeTree,h:String):String { // process an individual TypeTree 
    	return
    		switch(t){
    		case TTypedecl(tt):
    			//if(tt.isPrivate) // may need private types for inherritance
  				//	"";
				//else
				//	"type "+h+d2_(tt.path)+" "+haxe2goType(tt.type,h)+" // TTypedecl\n"; //TODO extend
				"type "+h+d2_(tt.path)+" uintptr /* TTypedecl -  "+tt.type+" */\n"; 

			case TPackage(name,full,subs): 
				var ret:String = "";
				for(s in subs)
					ret += tt(s,h);
				ret;
			case TEnumdecl(e):
				//if(e.isPrivate)
				//	"";
				//else
				//	"type "+h+ d2_(e.path) + " uintptr // TEnumdecl\n"; //TODO extend
				var ret = "type "+h+d2_(e.path)+" uintptr /* Enumdecl - "+e.constructors+" */\n\n";
				for(i in e.constructors)
					ret += "func "+h+d2_(e.path)+"_"+i.name+"_g() "+h+d2_(e.path)+" { return 0 }\n\n";
				ret;
			case TClassdecl(c) :
				if(!c.isPrivate /*&&
				c.path!="IMap"&&
				c.path!="haxe.web.Dispatch"&&
				c.path!="haxe.zip.HuffTools"&&
				c.path!="haxe.ds.TreeNode" */){ // exclusion list goes here
					var scName:String = "uintptr" ;
					if(c.superClass != null ) {
						scName= h+d2_(c.superClass.path) ;
							//trace(scName);
							//trace(c.superClass);
					}
					var clName:String = h+d2_(c.path);
					var ret:String = "" ;
					for(s in c.statics) {
						if(s.isPublic){
							switch(s.type){
							case CFunction(args,_ret):
								for(numArgs in 0...args.length+1){
									ret += "func "+h+d2_(c.path)+"_"+d2_(s.name)+ "_"+Std.string(numArgs)+"(";
									var hadFirst:Bool=false;
									var params:String="";
									var nparams:Int=0;
									for(a in args) {
										if(a.name!=""&&nparams<numArgs){
											if(hadFirst){
												ret+=",";
											}
											params += ","+h+a.name;
											ret += h+a.name ;
											if(!a.opt)
												ret += "_type_"+noComment(haxe2goParamType(a.t,h));
											//if(a.opt)
											//	ret += "_optional";
											if(a.value!=null && a.value!="null")
												ret += "_default_"+forGo(a.value);
											if(a.opt)
												ret += " "+haxe2goParamType(a.t,h);
											else
												ret += " interface{}";
											hadFirst=true;
											nparams+=1;
										}	
									}
									if(args.length>0) 
										ret += "";
									ret += ")";
									ret += haxe2goFuncBody("Call",s.type,h,c.path+"."+s.name,"",nparams,params,c.path);
									ret += "\n\n";
								}
							default:
								//ret += "var "+h+d2_(c.path)+"_"+d2_(s.name)+" "+haxe2goType(s.type,h)+"\n";
								// add getters & setters for static vars
								ret += "func "+h+ d2_(c.path) + "_"+d2_(s.name) +"_g() ";
								ret += haxe2goFuncBody("Get",s.type,h,c.path+"."+s.name,"",0,"","");
								ret += "\n\n";
								ret += "func "+h+ d2_(c.path) + "_"+d2_(s.name) +"_s(v ";
								ret += haxe2goType(s.type,h)+")";
								ret += haxe2goFuncBody("Set",s.type,h,c.path+"."+s.name,"",0,"","");
								ret += "\n\n";
							}
						}
					}
					var generic:String = "";
					for(postfix in [""].concat(c.params)){
						if(postfix!="")
							if(generic=="<Dynamic>")
								generic="<Dynamic,Dynamic>";
							else
								generic="<Dynamic>";
						var ul = postfix==""?"":"_";
						var typName:String = h+ d2_(c.path) + ul + postfix ;

						ret += "type "+ typName+ " "+scName+" // TClassdecl\n\n";
					}
					ret += "func (x " + h+d2_(c.path) + ") String() string { return `` }\n";			
					for(m in c.fields)
						if(m.isPublic)	{	
							switch(m.type){
							case CFunction(args,_ret):
								for(numArgs in 0...args.length+1){
									var mName:String="";
									if(m.name=="new"){
										ret += "func "+h+d2_(c.path)+"_" +d2_(m.name)+ "_"+Std.string(numArgs);
									} else {
										mName = h+d2_(m.name)+ "_"+Std.string(numArgs);
										ret += "func (x "+h+ d2_(c.path) + ") "+mName;
									}
									var bod:String="(";
									var hadFirst:Bool=false;
									var params:String="";
									var nparams:Int=0;
									for(a in args) {
										if(a.name!=""&&nparams<numArgs){
											if(hadFirst)
												bod+=",";
											bod += h+a.name ;
											if(!a.opt)
												bod += "_type_"+noComment(haxe2goParamType(a.t,h));
											//if(a.opt)
											//	bod += "_optional";
											if(a.value!=null && a.value!="null")
												bod += "_default_"+forGo(a.value);
											if(a.opt)
												bod += " "+haxe2goParamType(a.t,h);
											else
												bod += " interface{}";
											params += ","+h+a.name;
											nparams += 1;
											hadFirst=true;
										}	
									}
									if(args.length>0) 
										bod += "";
									bod += ")";
									if(m.name=="new") 
										bod+=" "+h+d2_(c.path)+" "+ 
											haxe2goFuncBody("New",m.type,h,c.path+generic,h+d2_(c.path),nparams,params,c.path+generic);
									else
										bod+=haxe2goFuncBody("Meth",m.type,h,m.name,"x",nparams,params,c.path+generic);
									ret += bod+"\n\n";
									if(mName!="")
										dotMap.set(clName+"_"+mName, {key: clName, super: scName, name: mName, body: bod} );										
								}
							default:
								{									
									ret += "func (x "+h+ d2_(c.path) + ") "+h+d2_(m.name) +"_g";
									var bod:String = "() "+haxe2goFuncBody("Fget",m.type,h,m.name,"x",0,"","");
									ret += bod+"\n\n";
									dotMap.set(clName+"_"+h+d2_(m.name)+"_g", {key: clName, super: scName, name: h+d2_(m.name)+"_g", body: bod} );

									ret += "func (x "+h+ d2_(c.path) + ") "+h+d2_(m.name) +"_s";
									bod = "(v "+haxe2goType(m.type,h)+")";
									bod += haxe2goFuncBody("Fset",m.type,h,m.name,"x",0,"","");
									ret += bod+"\n\n";
									dotMap.set(clName+"_"+h+d2_(m.name)+"_s", {key: clName, super: scName, name: h+d2_(m.name)+"_s", body: bod} );
								}
							}
						}
					ret;
				} else "";
			
			case TAbstractdecl(a): 
    			"type "+h+d2_(a.path)+" uintptr /* TAbstractdecl - "+a.athis+" */\n";
    		}
    }

 	static function forGo(s:Null<String>):String {
 		if(s==null)
 			return "";
 		if(StringTools.startsWith(s,"'"))
 			s = "_quote_"+s.substr(1,s.length-3)+"_quote_";
 		return StringTools.ltrim(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(
 			StringTools.urlEncode(s),".","_dot_"),"-","_minus_"),"%","_0x"),"null","nil"));
	}

    static function noComment(s:String):String {
    	var bits=s.split("/*");
    	var ret=bits[0];    	
    	for(b in 1 ... bits.length){
    		var pieces=bits[b].split("*/");
    		if(pieces.length>1)
    			ret+=pieces[1];
    	}
    	return StringTools.ltrim(StringTools.replace(ret,"{}","")); // to loose the interface{} brackets
    }
	
    static function d2_(x:String):String { // convert dots to underlines, underline to tripple underline
    	if(x==null)
    		return null;
    	if(x.length>2) {
	    	var r:String = x.split("_").join("...").split(".").join("_"); // transform orig "_" to "___" 
	    	r = r.split("<").join("XltX").split(">").join("XgtX"); // TODO consider how to deal with these chars
	    	return r;
    	} else
    		return x;
    }

 	static function haxe2goParamType(t:haxe.rtti.CType,h:String):String { // mapping of haxe to Go types, for use as a parameter
 		var base:String = haxe2goType(t,h);
 		if(StringTools.startsWith(base,"uintptr"))
 			return "interface{}";
 		else
 			return base;
	}
	
    static function haxe2goType(t:haxe.rtti.CType,h:String):String { // mapping of haxe to Go types
    	// TODO work out which of "Void" or Int/Float/Bool is actually the one used...
		switch(t){
		case CUnknown:
			return "uintptr"; // if in doubt, its a uintptr
		case CTypedef(name,params):
			//trace("CTypedef",name,params);
			switch(name) {
				case "Void": return "/*Void*/"; 
				case "Bool": return "bool";
				case "Int": return "int";
				case "UInt": return "uint";
				case "Float": return "float64";
				case "Null": return "/*Null<"+haxe2goType(params.first(),h)+">*/ interface{}";
				default: return className(name,params,h); 
			}
		case CFunction(args,_ret):
			//return "func ()"; // TODO should be: "func (args...) ret_"
			var rt:String = haxe2goType(_ret,h);
			if(rt=="/*Void*/")
				rt+= "uintptr";
			return  /*CFunction*/rt; 
		case CEnum(name,params):
			//trace("CEnum",name,params);
			switch(name) {
				case "Void": return "/*Void*/";
				case "Bool": return "bool";
				case "Int": return "int";
				case "UInt": return "uint";
				case "Float": return "float64";
				case "Null": return "/*Null<"+haxe2goType(params.first(),h)+">*/ interface{}";
				default: return className(name,params,h); 
			}
		case CDynamic(t):
			//trace("CDynamic",t);
			return "uintptr"; 
		case CClass(name,params):
			//trace("CClass",name,params);
			switch(name){
				case "Void": return "/*Void*/";
				case "String": return "string";
				case "Bool": return "bool";
				case "Int": return "int";
				case "UInt": return "uint";
				case "Float": return "float64";
				case "Null": return "/*Null<"+haxe2goType(params.first(),h)+">*/ interface{}";
				default: return className(name,params,h); 
			}
		case CAnonymous(fields):
			return "uintptr"; 
		case CAbstract(name,params):
			//trace("CAbstract",name,params);
			switch(name) {
				case "Void": return "/*Void*/";
				case "Bool": return "bool";
				case "Int": return "int";
				case "UInt": return "uint";
				case "Float": return "float64";		
				case "Null": return "/*Null<"+haxe2goType(params.first(),h)+">*/ interface{}";
				default: return className(name,params,h); 
			}
		}
		return "uintptr"; // if in doubt, its a uintptr
    }
	
	static function go2hxEnding(gt:String):String { // TODO - is this still required?
		switch(gt){
			case "/*Void*/": return "";
			case "string": return "String";
			case "int","uint": return "Int" ; //???
			case "float64": return "Float" ;
			case "bool": return "Bool";
			case "interface{}": return "IFace"; //???
			case "uintptr": return "Dynamic";
			}
			return "Dynamic";
	}

  	static function goDefVal(gt:String):String {
		switch(gt){
			case "/*Void*/": return "";
			case "string": return "\"\"";
			case "int","uint": return "0" ;
			case "float64": return "0.0" ;
			case "bool": return "false";
		}
		if(StringTools.endsWith(gt,"interface{}"))
 			return "nil";
		return "0";
	}

	static function goTypeCast(gt:String,start:Bool):String {
		switch(gt){
			case "/*Void*/": return "";
			case "string": return "";
			case "int","uint": return "" ;
			case "float64": return "" ;
			case "bool": return "";
			case "uintptr": return "";
			}
		if(StringTools.endsWith(gt,"interface{}"))
 			return "";
		if(start)
			return gt+"(";
		else
			return ")";
	}
	static function getPrefixLogic(p:String,ht:String):String{
		//trace(t);
		if(p=="X"&&ht.substr(0,4)=="sys.")
			return "\" !js && !flash \"";
		switch(p){
			case "X": return "\"\"";
			case "P": return "\"cpp\"";
			case "R": return "\"cs\"";
			case "F": return "\"flash\"";
			case "J": return "\"java\"";
			case "S": return "\"js\"";
			case "N": return "\"neko\"";
			case "H": return "\"php\"";
		}
		return "UNKNOWN_TARGET";
	}
    static function haxe2goFuncBody(a:String,t:haxe.rtti.CType,h:String,hName:String,rx:String,np:Int,ps:String,ht:String):String { // create a go function body
		var gt:String = haxe2goType(t,h);
		var grt:String = gt;
		if(gt== "/*Void*/uintptr")
			grt = "/*Void*/";
		var rt:String = go2hxEnding(grt);
		var ret:String = " ";
		if(a!="Set" && a!="Fset" && a!="New")
			ret +=  grt + " {\n\t return " + goTypeCast(grt,true);
		else
			ret += "{\n\t";
			/*
			ret += "hx."+a;
			if(a!="New")
				ret+=rt;
			ret +="(";
			ret += getPrefixLogic(h,ht)+",";
			if(a=="Fset"||a=="Fget"||a=="Meth")
				ret += "uintptr("+rx+"),";
			if(a=="Meth")
				ret += "\""+ht+"\""+",";
			ret += "\""+hName+"\"";
			if(a=="Set"||a=="Fset")
				if(rt=="Dynamic" && grt!="uintptr")
					ret += ",uintptr(v)";
				else
					ret += ",v";

			if(a=="Call"||a=="Meth"||a=="New")
				ret += "," + np + ps;
			*/
			//if(a!="Set" && a!="Fset" && grt!="/*Void*/")
			//	return ret + ")"+goTypeCast(grt,false)+"\n}\n";
			//else
			//	return ret + ")"+"\n}\n";
			if(a!="Set" && a!="Fset")
				if(a=="New")
					return ret + "return " + rx + "(0)" +"\n}\n";
				else
					return ret + goDefVal(grt) + goTypeCast(grt,false)+"\n}\n";
			else
				return ret + "\n}\n";
    }
	
    static function className(name:String, params:List<haxe.rtti.CType>,h:String):String{ // maybe use a go class name, if declared
					if(isDeclared(name,parser.root))
						return h+d2_(name); 
					else
						return "uintptr";
    }
	
    static function isDeclared(name:String,tree:haxe.rtti.TypeRoot):Bool { // itterate through the decalrations to check that a type is actually declared
    	for(tt in tree)
    		if(isDeclaredHere(name,tt))
    			return true;
    	return false;
    }
	
    static function isDeclaredHere(n:String,tree:haxe.rtti.TypeTree):Bool { // look for the type in this particular spot on the tree
    		switch(tree){
    		case TTypedecl(tt):
    			if(tt.isPrivate) 
  					return false;
				else
					return tt.path==n;
			case TPackage(name,full,subs):
				for(s in subs)
					if(isDeclaredHere(n,s))
						return true;
				return false;
			case TEnumdecl(e):
				if(e.isPrivate)
					return false;
				else
					return e.path==n;
			case TClassdecl(c):
				if(c.isPrivate)
					return false;
				else {
					// TODO check that this code always works correctly
					for(postfix in [""].concat(c.params)){
						var ul = postfix==""?"":".";
						if( (c.path + ul + postfix) ==n )
							return true;
					}
					return false;
				} 
			case TAbstractdecl(a): 
    			if(a.isPrivate)
    				return false;
    			else
	    			return a.path==n;
    		}	
    		return false;
    }
}


class FileUtils // this class modified from http://haxe.org/doc/snip/writetextfilewithbom
{
    /** Write out a text file with correct BOM for UTF-8 encoding */
    public static function writeTextFileWithBOM(text:String,filePath:String):Void
    {
        var f:FileOutput=File.write(filePath,true);
        //NOTE or without BOM as it messes up +build processing
        //f.writeByte(239);
        //f.writeByte(187);
        //f.writeByte(191);
        f.writeByte(0xA); // newline
        f.writeString(text);
        f.close();
    }
    
}


